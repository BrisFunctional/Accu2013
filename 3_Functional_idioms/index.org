#+TITLE: Functional idioms
#+AUTHOR: Matthew Gilliard and Thom Leggett

* Functional Idioms                                                   :slide:
** Immutability                                                       :slide:
** Immutability                                                       :slide:
  + Immutable things do not change over time
*** Matthew's notes                                                   :notes:
  + A common objection - SO SLOW
  + Can be implemented with copy-on-write
    * Makes a complete copy on every change
  + Better to use persistent datastructures
*** Persistent data structures                                        :slide:
  + "a data structure that always preserves the previous version of itself when it is modified."
    * [[http://en.wikipedia.org/wiki/Persistent_data_structure][wikipedia of course :)]]
  + (nothing to do with database-style persistence)
*** Structural sharing                                                :slide:
  + A way of making persistent data structures efficiently
  + Lets do an example...
*** one: stack                                                        :slide:
*** one: stack                                                        :slide:
    #+BEGIN_SRC python
  + s0 = empty_stack()
    #+END_SRC
*** one: stack                                                        :slide:
    #+BEGIN_SRC python
  + s0 = empty_stack()
  + s1 = push(s0, "Z")
    #+END_SRC
*** one: stack                                                        :slide:
    #+BEGIN_SRC python
  + s0 = empty_stack()
  + s1 = push(s0, "Z")
  + s2 = push(s1, "Y")
    #+END_SRC
*** one: stack                                                        :slide:
    #+BEGIN_SRC python
  + s0 = empty_stack()
  + s1 = push(s0, "Z")
  + s2 = push(s1, "Y")
  + s3 = push(s2, "X")
    #+END_SRC
*** one: stack                                                        :slide:
    #+BEGIN_SRC python
  + s0 = empty_stack()
  + s1 = push(s0, "Z")
  + s2 = push(s1, "Y")
  + s3 = push(s2, "X")
  + [v, s4] = pop(s3)
    #+END_SRC
*** one: stack                                                        :slide:
    #+BEGIN_SRC python
  + s0 = empty_stack()
  + s1 = push(s0, "Z")
  + s2 = push(s1, "Y")
  + s3 = push(s2, "X")
  + [v, s4] = pop(s3) ;; v == "X", s4 == s2
    #+END_SRC
*** one: stack                                                        :slide:
    #+BEGIN_SRC python
  + s0 = empty_stack()
  + s1 = push(s0, "Z")
  + s2 = push(s1, "Y")
  + s3 = push(s2, "X")
  + [v, s4] = pop(s3) ;; v == "X", s4 == s2
  + s5 = push(s4, "Q")
    #+END_SRC

*** two: sorted set                                                   :slide:
*** two: sorted set                                                   :slide:
    #+BEGIN_SRC python
  + s1 = ["a", "b", "c", "d", "f", "g", "h"]
    #+END_SRC
*** two: sorted set                                                   :slide:
    #+BEGIN_SRC python
  + s1 = ["a", "b", "c", "d", "f", "g", "h"]
  + contains?(s1, "e")
    #+END_SRC
*** two: sorted set                                                   :slide:
    #+BEGIN_SRC python
  + s1 = ["a", "b", "c", "d", "f", "g", "h"]
  + contains?(s1, "e")
  + s2 = insert(s, "e")
    #+END_SRC
*** three: doubly-linked lists                                        :slide:
*** three: doubly-linked lists                                        :slide:
  + ???
*** four: trees (again)                                               :slide:
*** four: trees (again)                                               :slide:
  [[./branched_tree.png]]
*** four: trees (again)                                               :slide:
  [[./high_branching_factor.jpg]]
*** Language support                                                  :slide:
  + If not provided with the core language, we can make a library
    * eg [[http://code.google.com/p/pcollections/]]

** Higher-Order Functions                                             :slide:
   [[./Left-fold-transformation.png]]

   [[./Right-fold-transformation.png]]


   [[http://en.wikipedia.org/wiki/Fold_(higher-order_function)]]
*** First-class functions                                             :slide:
    + Takes a function as an argument.
    + Can return a function as a result.

*** Closures and lambdas                                              :slide:
    + Not strictly necessary, but...

*** Speaks your language?                                             :slide:
    + C
      * Kinda. Function pointers get you some of the way there.
    + C++
      * Yes. Check the [[http://sourceforge.net/projects/fcpp/][FC++]] project. Also: lazyness, monads.
    + Python
      #+BEGIN_SRC python
      import functools
      #+END_SRC
    + Java
      * Yes but it's clunky.
    + JavaScript
      + Totally!

*** Haskell type notation                                             :slide:
    #+BEGIN_SRC haskell

    one :: a -> [a] -> [a]

    two :: (b -> c) -> (a -> b) -> a -> c

    three :: (a -> b) -> [a] -> [b]

    four :: (a -> Bool) -> [a] -> [a]

    five :: (a -> b -> a) -> a -> [b] -> a

    #+END_SRC
**** Notes                                                            :notes:
     + Currying

*** two: Composition                                                  :slide:
    #+BEGIN_SRC haskell
    comp :: (b -> c) -> (a -> b) -> a -> c
    #+END_SRC
    + Takes two functions, f and g.
    + Returns a new function x -> f(g(x)).

*** three: Map                                                        :slide:
    #+BEGIN_SRC haskell
    map :: (a -> b) -> [a] -> [b]
    #+END_SRC
    + Takes a function and a list.
    + Returns a new list with the results of applying the function to all
      elements of the list in order.

*** four: Filter                                                      :slide:
    #+BEGIN_SRC haskell
    filter :: (a -> Bool) -> [a] -> [a]
    #+END_SRC
    + Takes a predicate and a list.
    + Returns a new list containing only items which, when passed to the
      predicate, the predicate returned true.

*** five: Reduce                                                      :slide:
    #+BEGIN_SRC haskell
    reduce :: (a -> b -> a) -> a -> [b] -> a
    #+END_SRC
    + Takes a function that combines two values in some way, an initial value
      and a list.
    + Returns a value obtained by passing the first item of the list and the
      initial value to the function, then calls the function with the result
      of the last call and the second item of the list etc.

** Laziness                                                           :slide:
*** Matthew's notes                                                   :notes:
  + See the example

** +Iteration+ Recursion                                              :slide:

* org-html-slideshow incantations
#+TAGS: slide(s) notes(n)

#+STYLE: <link rel="stylesheet" type="text/css" href="../org-html-slideshow/common.css" />
#+STYLE: <link rel="stylesheet" type="text/css" href="../org-html-slideshow/screen.css" media="screen" />
#+STYLE: <link rel="stylesheet" type="text/css" href="../org-html-slideshow/projection.css" media="projection" />
#+STYLE: <link rel="stylesheet" type="text/css" href="../org-html-slideshow/presenter.css" media="presenter" />

#+BEGIN_HTML
<script type="text/javascript" src="../org-html-slideshow/org-html-slideshow.js"></script>
#+END_HTML

#+OPTIONS:   H:6 num:t toc:t \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

# Local Variables:
# org-export-html-style-include-default: nil
# org-export-html-style-include-scripts: nil
  # End:
