#+TITLE: Functional idioms
#+AUTHOR: Matthew Gilliard and Thom Leggett

* Functional Idioms                                                   :slide:
** Immutability                                                       :slide:
*** Matthew's notes                                                   :notes:
  + A common objection - SO SLOW
  + Can be implemented with copy-on-write
    * Write grabs a lock to prevent simultaneous writes
    * Makes a complete copy
    * Reads are never locked out
  + Better to use persistent datastructures
*** Persistent data structures                                        :slide:
  + "a data structure that always preserves the previous version of itself when it is modified."
    * [[http://en.wikipedia.org/wiki/Persistent_data_structure][wikipedia of course :)]]
  + (nothing to do with database-style persistence)
*** Structural sharing                                                :slide:
  + A way of making persistent data structures efficiently
  + Lets do an example...
*** Stack                                                             :slide:
*** Stack                                                             :slide:
  + s0 = empty_stack()
*** Stack                                                             :slide:
  + s0 = empty_stack()
  + s1 = push(s0, "Z")
*** Stack                                                             :slide:
  + s0 = empty_stack()
  + s1 = push(s0, "Z")
  + s2 = push(s1, "Y")
*** Stack                                                             :slide:
  + s0 = empty_stack()
  + s1 = push(s0, "Z")
  + s2 = push(s1, "Y")
  + s3 = push(s2, "X")
*** Stack                                                             :slide:
  + s0 = empty_stack()
  + s1 = push(s0, "Z")
  + s2 = push(s1, "Y")
  + s3 = push(s2, "X")
  + [v, s4] = pop(s3)
*** Stack                                                             :slide:
  + s0 = empty_stack()
  + s1 = push(s0, "Z")
  + s2 = push(s1, "Y")
  + s3 = push(s2, "X")
  + [v, s4] = pop(s3) ;; v == "X", s4 == s2
*** Stack                                                             :slide:
  + s0 = empty_stack()
  + s1 = push(s0, "Z")
  + s2 = push(s1, "Y")
  + s3 = push(s2, "X")
  + [v, s4] = pop(s3) ;; v == "X", s4 == s2
  + s5 = push(s4, "Q")

*** Sorted Set                                                        :slide:
*** Sorted Set                                                        :slide:
  + s1 = ["a", "b", "c", "d", "f", "g", "h"]
*** Sorted Set                                                        :slide:
  + s1 = ["a", "b", "c", "d", "f", "g", "h"]
  + s2 = insert(s, "e")
*** Doubly-linked lists                                               :slide:
*** Doubly-linked lists                                               :slide:
  + ???
*** Trees (again)                                                     :slide:
*** Trees (again)                                                     :slide:
  [[http://2.bp.blogspot.com/_8lmIIa0-Kqg/TThSYumxowI/AAAAAAAAIhw/93N1w50bumU/s1600/bates2.jpg]]

*** Language support                                                  :slide:
  + If not provided with the core language, we can make a library
    * eg [[http://code.google.com/p/pcollections/]]

** Higher-Order Functions                                             :slide:
*** First-class functions                                             :slide:
  + Takes a function as an argument.
  + Can return a function as a result.
*** Closures and lambdas                                              :slide:
  + Not strictly necessary, but...
*** Speaks your language?                                             :slide:
  + C
    * Kinda. Function pointers get you some of the way there.
  + C++
    * Yes. Check the [[http://sourceforge.net/projects/fcpp/][FC++]] project. Also: lazyness, monads.
  + Python
    #+BEGIN_SRC python
    import functools
    #+END_SRC
  + Java
    * Yes but it's clunky.
  + JavaScript
    + Totally!
*** Haskell type notation                                             :slide:
  #+BEGIN_SRC haskell
  cons :: a -> [a] -> [a]
  comp :: (b -> c) -> (a -> b) -> a -> c
  map :: (a -> b) -> [a] -> [b]
  filter :: (a -> Bool) -> [a] -> [a]
  reduce :: (a -> b -> a) -> a -> [b] -> a
  #+END_SRC
*** Notes                                                             :notes:
  + Currying
*** Composition                                                       :slide:
  #+BEGIN_SRC haskell
  comp :: (b -> c) -> (a -> b) -> a -> c
  #+END_SRC
  + Takes two functions, f and g.
  + Returns a new function x -> f(g(x)).
*** Map                                                               :slide:
  #+BEGIN_SRC haskell
  map :: (a -> b) -> [a] -> [b]
  #+END_SRC
  + Takes a function and a list.
  + Returns a new list with the results of applying the function to all
    elements of the list in order.
*** Filter                                                            :slide:
  #+BEGIN_SRC haskell
  filter :: (a -> Bool) -> [a] -> [a]
  #+END_SRC
  + Takes a predicate and a list.
  + Returns a new list containing only items which, when passed to the
    predicate, the predicate returned true.
*** Reduce                                                            :slide:
  #+BEGIN_SRC haskell
  reduce :: (a -> b -> a) -> a -> [b] -> a
  #+END_SRC
  + Takes a function that combines two values in some way, an initial value
    and a list.
  + Returns a value obtained by passing the first item of the list and the
    initial value to the function, then calls the function with the result
    of the last call and the second item of the list etc.
** Laziness                                                           :slide:
*** Matthew's notes                                                   :notes:
  + See the example

* org-html-slideshow incantations
#+TAGS: slide(s) notes(n)

#+STYLE: <link rel="stylesheet" type="text/css" href="../org-html-slideshow/common.css" />
#+STYLE: <link rel="stylesheet" type="text/css" href="../org-html-slideshow/screen.css" media="screen" />
#+STYLE: <link rel="stylesheet" type="text/css" href="../org-html-slideshow/projection.css" media="projection" />
#+STYLE: <link rel="stylesheet" type="text/css" href="../org-html-slideshow/presenter.css" media="presenter" />

#+BEGIN_HTML
<script type="text/javascript" src="../org-html-slideshow/org-html-slideshow.js"></script>
#+END_HTML

#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

# Local Variables:
# org-export-html-style-include-default: nil
# org-export-html-style-include-scripts: nil
  # End:
